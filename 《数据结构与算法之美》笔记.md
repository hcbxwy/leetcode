# 数据结构与算法之美笔记
## 1. 入门篇
```
文章提到的书：
1. 《算法导论》
2. 《大话数据结构》（适合新手）
3. 《算法图解》（适合新手）
```
### 1.1 为什么要学习数据结构与算法？<br>
1. 入职大厂，算法必考;
2. 学了算法，容易写出性能更优的代码;
3. 算法，是一种解决问题的思路和方法，有机会应用到生活和事业的其他方面;
4. 长期来看，大脑思考能力是个人最重要的核心竞争力，而算法是为数不多的能够有效训练大脑思考能力的途径之一。
### 1.2 如何高效地学习数据结构与算法？
1. 理解什么是数据结构？什么是算法？
```
从广义上讲，数据结构就是指一组数据的存储结构，算法就是操作数据的一组方法。
从狭义上讲，是指某些著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等。
数据结构和算法是相辅相成的，数据结构为算法服务，而算法要作用在特定的数据结构上。
```
2. 学习的重点在什么地方？
```
首先要掌握数据结构和算法最重要的概念——复杂度分析；
```
3. 数据结构与算法重要知识点如下图
![算法知识点](images/数据结构与算法知识点.jpg)
4. 集中攻克最基础、最常用的20个数据结构与算法，足以应付面试和工作需要，具体如下：
```
10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Tree 树
10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法
```
5. 不要死记硬背，而是学习数据结构与算法的`来历`、`自身特点`、`适合解决的问题`以及`实际应用场景`
6. 事半功倍的学习技巧
```
（1）边学边练，适度刷题
（2）多问、多思考、多互动
（3）打怪升级学习法
（4）知识需要沉淀，不要想试图一下子掌握所有
```
7. 我的打怪升级学习法
```
（1）每学完一篇文章后做笔记
（2）刷完每章评论，记录好的问答
（3）每一章例子都用Java实现一遍
```
### 1.3 复杂度分析
1. 为什么需要复杂度分析？
```
因为，直接执行代码，通过监控、统计等方式（即事后统计法）得到的结果有比较大的局限性
（1）测试结果非常依赖测试环境
（2）测试结果受数据规模的影响很大
所以，需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。
```
2. 复杂度分析有哪些？
```
用大 O 复杂度表示法，分时间时间复杂度分析和空间复杂度分析
（1）时间复杂度分析：表示算法的执行时间与数据规模之间的增长关系
    * 只关注循环执行次数最多的一段代码
    * 加法法则：总复杂度等于量级最大的那段代码的复杂度
    * 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
（2）常见的时间复杂度量级有：
    常量阶 O(1)
    对数阶 O(logn)    
    线性阶 O(n)
    线性对数阶 O(nlogn)
    平方阶 O(n²)、立方阶 O(n³)、……、K方阶 O(n^k)
    指数阶 O(2^n)-非多项式量级，用得较少，不用深究
    阶乘阶 O(n!)-非多项式量级，用得较少，不用深究
（3）空间复杂度分析：表示算法的存储空间与数据规模之间的增长关系
    常用的空间复杂度量级有：O(1)、O(n)、O(n²)
3. 最好情况复杂度、最坏情况复杂度、平均情况复杂度、均摊情况复杂度
    重点区分下平均情况复杂度与均摊情况复杂度：
    （1）首先，均摊情况复杂度是特殊的平均情况复杂度
    （2）当对一组数据进行一连串的操作过程中，大部分情况下时间复杂度都很低，只是个别情况下时间复杂度很高，
        而且这些操作之间存在前后连贯的时序关系，这时就可以使用摊还分析法得出均摊情况复杂度。
        摊还分析法即把个别出现的高时间复杂度平摊到其他低时间复杂度，得到的结果大多时候都等于最好情况复杂度。
```
## 2. 基础篇之数据结构
### 2.1 数组
1. 数组是什么？  
数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。
2. 数组有什么特点？
    - 线性表
    - 连续的内存空间
    - 存储相同数据类型
    - 可根据下标随机访问
    - 低效的插入和删除
3. 数组与容器
4. 数组寻址公式  
    - 一维数组a[i]寻址公式：base_addr + i * size
    - m x n的二维数组a[i][j]寻址公式：base_addr + (i * n + j) * size
5. 实战演练
    - 实现LRU缓存淘汰算法    
### 2.2 链表
1. 链表是什么？
    - 和数组一样，链表也是一种线性表
    - 从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。
    - 链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针Next。
2. 为什么使用链表？即链表的特点
    - 插入和删除数据效率高，O(1)级别，因为只需更改指针指向即可；查询数据效率低，O(n)级别，因为需要从链头遍历到链尾。
    - 和数组相比，内存空间消耗更大，因为节点除了存储数据，还要存储后即指针Next。
3. 常用链表：单链表、双向链表、循环链表、双向循环链表
4. 链表与数组比较
5. 写链表代码技巧
    - 理解指针或引用的含义
    - 警惕指针丢失和内存泄露
    - 利用哨兵简化实现难度
    - 重点留意边界条件处理
    - 举例画图，辅助思考
    - 多写多练，没有捷径
6. 实战演练（LeetCode题号：206，141，21，19，876）
    - 实现LRU缓存淘汰算法
    - 处理约瑟夫问题
    - 研究LinkedHashMap实现原理（双向链表）
    - 用代码实现一个可以动态扩容的链表
    - 判断一个字符串是否是回文字符串
    - 实现链表反转
    - 合并两个有序链表
    - 用哨兵实现在数组a中，查找key，返回key所在位置
    - 链表中环的检测
    - 删除链表倒数第n个节点
    - 求链表的中间节点
### 2.3 栈
1. 是什么?
```
栈是一种操作受限的数据结构，只支持出栈和入栈操作，后进先出是它最大的特点。
```
2. 为什么?
```
从功能上看，数组和链表确实可以替代栈，但特定的数据结构是对特定场景的抽象，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然就更容易出错。
所以，当某个数据集合只涉及在一端插入和删除数据，并且满足先进后出、后进先出的特性，我们就应该首选"栈"这种数据结构。
```
3. 应用场景
    - 函数调用栈
    - 表达式求值
    - 检查表达式中的括号是否匹配
    - 实现浏览器的前进和后退功能
4. 实战演练
    - 用数组实现一个支持动态扩容栈（即顺序栈）
    - 用链表实现一个支持动态扩容栈（即链式栈）
    - 用代码实现上面第3点列出的应用场景
    - LeetCode上栈的题目：20,155,232,844,224,682,496
### 2.4 队列
1. 是什么？
```
队列和栈一样，也是一种操作受限的数据结构，只支持入队和出队两种操作，先进先出是它最大的特点。
```
2. 为什么？
```
作为一种非常基础的数据机构，应用非常广泛：比如循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起到关键性的作用。
```
3. 常用队列有：顺序队列、链式队列、循环队列、阻塞队列、并发队列
4、实战演练
    - 用数组实现（即顺序队列）
    - 用链表实现（即链式队列）
    - 用代码实现循环队列（解决数据搬移问题）
## 3. 基础篇之算法
### 3.1 递归
1. What？
```
递归，即先递再归，是一种应用非常广泛的算法或编程技巧。所有的递归问题都可以用递推公式来表示。
递归需要满足三个条件：
① 一个问题的解可以分解成几个子问题的解
② 这个问题与分解后的子问题，除了数据规模不同，求解思路完全一样
③ 存在递归终止条件
```
2. How？
```
一、编写技巧：只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。
① 找到如何将大问题分解成小问题的规律
② 写出地推公式，找到终止条件
③ 将递推公式和终止条件翻译成代码
```
3. Problem？
    - 需要警惕堆栈溢出
    - 需要警惕重复计算
4. 实战演练
    - 掌握如何将递归改写成非递归方式
    - 掌握避免堆栈溢出的写法
    - 掌握避免重复计算的写法
    - LeetCode专项练习
### 3.2 排序
如何分析一个排序算法？
- 排序算法的执行效率
    - 最好情况、最坏情况、平均情况时间复杂度
    - 时间复杂度的系数、常数、低阶
    - 比较次数和交换（移动）次数
- 排序算法的内存消耗：原地排序，即空间复杂度为O(1)
- 排序算法的稳定性：即值相同的元素经过排序后位置有无改变
#### 3.2.1 冒泡排序（Bubble Sort）
1. 定义<br>
    冒泡排序只会操作相邻的两个元素。
    每次冒泡操作都会对相邻的两个元素进行比较，然后根据大小进行互换位置。
    一次冒泡会让至少一个元素移动到它应该在的位置。
2. 评价<br>
    第一、冒泡排序是原地排序算法吗？
    第二、冒泡排序是稳定的排序算法吗？
    第三、冒泡排序是时间复杂度是多少？（最好、最坏、平均；逆序度=满有序度-有序度）
#### 3.2.2 插入排序（Insertion Sort）
1. 定义<br>
    插入排序把数据分为两个区间：已排序区间和未排序区间。
    其核心思想是取未排序中的元素，在已排序区间中找到合适的位置将其插入，并保证已排序区间一直有序。
2. 评价：原地？稳定？时间复杂度多少？空间复杂度多少？
3. 优化：希尔排序
#### 3.2.3 选择排序（Selection Sort）
1. 定义<br>
    选择排序也把数据分为两个区间：已排序区间和未排序区间。
    其核心思想是每次从未排序区间找到最小元素，并放入已排序区间末尾。
2. 评价：原地？稳定？时间复杂度多少？空间复杂度多少？
#### 3.2.4 归并排序（Merge Sort）
- 原理
```
使用分治思想，把一个数组从中间分成前后两部分，然后前后两部分分别排序，最后再合并在一起排序。
```
- 评价：原地？稳定？时间复杂度多少？空间复杂度多少？
- 关键知识
    - 使用递归，理解递推公式
    - 掌握时间、空间复杂度分析推导过程
#### 3.2.5 快速排序（Quick Sort）
- 原理
```
如果要排序数组下标p到r之间的一组数据，选择p到r之间任意一个数据作为pivot（分区点）；
遍历p到r的数据，小于pivot的放到左边，大于的放到右边，pivot放到中间，经过这一步骤后数据分成了三部分；
根据分治、递归的处理思想，用递归排序下标p到q-1之间的数据，和下标q+1到r之间的数据，直到区间缩小到1，就说明所有数据都有序了。
```
- 评价：原地？稳定？时间复杂度多少？空间复杂度多少？
- 与归并排序相比有哪些区别？
    - 归并排序的处理是由下到上，即先处理子问题再合并
    - 快速排序的处理是由上到下，即先分区再处理子问题
    - 归并排序非原地排序，而快排则是
#### 面试题
- 冒泡排序和插入排序的时间复杂度都是 O(n2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？
- 如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素？
- 现在你有 10 个接口访问日志文件，每个日志文件大小约 300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有 1GB，你有什么好的解决思路，能“快速”地将这 10 个日志文件合并吗？
#### 实战演练
- 用代码实现【冒泡排序】算法
- 用代码实现【插入排序】算法
- 用代码实现【选择排序】算法
- 用代码实现【归并排序】算法
- 用代码实现【快速排序】算法